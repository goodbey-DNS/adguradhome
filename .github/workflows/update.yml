name: AdGuardHome Auto Update
# Description: Automatically checks for AdGuardHome updates daily at 6 AM Beijing time (UTC 22:00)
# and maintains a fixed download URL that always points to the latest version.
# 
# Features:
# - Daily automated version checks
# - Fixed download URL (never changes)
# - SHA256 integrity verification
# - Comprehensive error handling and logging
# - Retry mechanism with exponential backoff
# - Security scanning for downloaded files
# - Notification support (configurable)
# - Performance monitoring and metrics

on:
  schedule:
    - cron: '0 22 * * *'  # 6 AM Beijing Time (UTC+8)
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update even if version is current'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: write
  issues: write  # For creating issues on failure
  actions: read   # For workflow metrics

env:
  # Repository settings
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  
  # Network settings
  TIMEOUT: 30
  RETRIES: 3
  RETRY_DELAY_BASE: 2
  
  # Security settings
  MIN_FILE_SIZE: 10000000  # 10MB minimum
  MAX_FILE_SIZE: 50000000  # 50MB maximum
  
  # Performance settings
  CURL_MAX_TIME: 300  # 5 minutes for download
  
  # Notification settings (optional)
  # ENABLE_NOTIFICATIONS: 'false'  # Set to 'true' to enable
  # NOTIFY_ON_SUCCESS: 'true'
  # NOTIFY_ON_FAILURE: 'true'

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: adguard-update
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache API responses
        uses: actions/cache@v4
        with:
          path: ~/.cache/api-responses
          key: api-cache-adguard-${{ github.run_id }}
          restore-keys: |
            api-cache-adguard-

      - name: Setup tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq curl
          echo "jq version: $(jq --version)"
          echo "curl version: $(curl --version | head -n1)"

      - name: Initialize workflow
        id: init
        run: |
          set -euo pipefail
          START_TIME=$(date +%s)
          echo "start_time=$START_TIME" >> "$GITHUB_OUTPUT"
          echo "workflow_id=${{ github.run_id }}" >> "$GITHUB_OUTPUT"
          echo "workflow_started_at=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$GITHUB_OUTPUT"
          
          # Create working directory
          mkdir -p "${{ github.workspace }}/downloads"
          cd "${{ github.workspace }}/downloads"
          
          echo "âœ“ Workflow initialization completed"
          echo "  - Repository: ${{ github.repository }}"
          echo "  - Runner: ${{ runner.os }}"
          echo "  - Architecture: ${{ env.ARCH }}"
          echo "  - Force update: ${{ github.event.inputs.force_update || 'false' }}"

      - name: Get latest version
        id: version
        run: |
          set -euo pipefail
          get_version() {
            curl -s --max-time ${{ env.TIMEOUT }} \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ env.REPO }}/releases/latest" \
              2>/dev/null | jq -r '.tag_name // empty' | sed 's/^v//'
          }
          
          VERSION=""
          for i in $(seq 1 ${{ env.RETRIES }}); do
            VERSION=$(get_version)
            if [[ -n "$VERSION" ]]; then
              echo "Latest version: $VERSION"
              echo "version=$VERSION" >> "$GITHUB_OUTPUT"
              break
            fi
            echo "Attempt $i failed, retrying..."
            sleep $((2 ** i))
          done
          
          if [[ -z "$VERSION" ]]; then
            echo "Error: Cannot get version after ${{ env.RETRIES }} attempts"
            exit 1
          fi

      - name: Get current version
        id: current
        run: |
          set -euo pipefail
          RESPONSE=$(curl -s --max-time ${{ env.TIMEOUT }} \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/v-latest" \
            2>/dev/null || echo "")
          
          if [[ -z "$RESPONSE" ]] || [[ "$(echo "$RESPONSE" | jq -r '.message // empty')" == "Not Found" ]]; then
            CURRENT="none"
          else
            CURRENT=$(echo "$RESPONSE" | jq -r '.name // "none"' | sed 's/^.*v\([0-9.]*\).*$/\1/' || echo "none")
          fi
          
          echo "Current version: $CURRENT"
          echo "current=$CURRENT" >> "$GITHUB_OUTPUT"

      - name: Compare versions
        id: compare
        run: |
          set -euo pipefail
          LATEST="${{ steps.version.outputs.version }}"
          CURRENT="${{ steps.current.outputs.current }}"
          
          echo "=== Version Comparison ==="
          echo "Latest from official: $LATEST"
          echo "Current in repo: $CURRENT"
          echo "========================="
          
          if [[ "$CURRENT" == "none" ]] || [[ "$CURRENT" != "$LATEST" ]]; then
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
            echo "Update needed: $CURRENT â†’ $LATEST"
          else
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
            echo "Already latest: v$LATEST"
          fi

      - name: Download AdGuardHome
        if: steps.compare.outputs.needs_update == 'true'
        id: download
        run: |
          set -euo pipefail
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="AdGuardHome_${{ env.ARCH }}.tar.gz"
          SHA256SUMS="AdGuardHome_${{ env.ARCH }}.tar.gz.sha256"
          BASE_URL="https://github.com/${{ env.REPO }}/releases/download/v${VERSION}"
          
          echo "â¬‡ï¸  Starting download..."
          echo "   Version: v${VERSION}"
          echo "   Files: ${FILENAME}, ${SHA256SUMS}"
          
          DOWNLOAD_START=$(date +%s)
          
          for i in $(seq 1 ${{ env.RETRIES }}); do
            echo ""
            echo "ğŸ“¥ Download attempt $i of ${{ env.RETRIES }}..."
            
            # Use parallel downloads with background jobs
            curl -L --max-time ${{ env.CURL_MAX_TIME }} --retry 3 --retry-delay 5 \
              -o "$FILENAME" "${BASE_URL}/${FILENAME}" &
            CURL_PID1=$!
            
            curl -L --max-time ${{ env.TIMEOUT }} --retry 3 --retry-delay 5 \
              -o "$SHA256SUMS" "${BASE_URL}/${SHA256SUMS}" &
            CURL_PID2=$!
            
            # Wait for both downloads to complete
            wait $CURL_PID1
            EXIT_CODE1=$?
            wait $CURL_PID2
            EXIT_CODE2=$?
            
            if [[ $EXIT_CODE1 -eq 0 ]] && [[ $EXIT_CODE2 -eq 0 ]] && \
               [[ -f "$FILENAME" ]] && [[ -f "$SHA256SUMS" ]]; then
              echo "âœ“ Both files downloaded successfully"
              break
            fi
            
            echo "âš ï¸  Download attempt $i failed (exit codes: $EXIT_CODE1, $EXIT_CODE2)"
            
            if [[ $i -eq ${{ env.RETRIES }} ]]; then
              echo "âŒ Error: Download failed after ${{ env.RETRIES }} attempts"
              exit 1
            fi
            
            # Clean up partial downloads
            rm -f "$FILENAME" "$SHA256SUMS"
            
            # Exponential backoff
            BACKOFF=$(( ${{ env.RETRY_DELAY_BASE }} ** i ))
            echo "â³ Waiting ${BACKOFF}s before retry..."
            sleep $BACKOFF
          done
          
          DOWNLOAD_END=$(date +%s)
          DOWNLOAD_DURATION=$((DOWNLOAD_END - DOWNLOAD_START))
          
          # Get file sizes
          FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || echo 0)
          SHA_SIZE=$(stat -c%s "$SHA256SUMS" 2>/dev/null || echo 0)
          
          echo ""
          echo "âœ“ Download completed in ${DOWNLOAD_DURATION}s"
          echo "  - Main file: $(( FILE_SIZE / 1024 / 1024 ))MB"
          echo "  - Checksum:  $(( SHA_SIZE / 1024 ))KB"
          
          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "sha256file=$SHA256SUMS" >> "$GITHUB_OUTPUT"
          echo "download_duration=$DOWNLOAD_DURATION" >> "$GITHUB_OUTPUT"

      - name: Verify download integrity
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          FILENAME="${{ steps.download.outputs.filename }}"
          SHA256FILE="${{ steps.download.outputs.sha256file }}"
          
          echo "ğŸ” Starting integrity verification..."
          
          # Check files exist
          if [[ ! -f "$SHA256FILE" ]] || [[ ! -f "$FILENAME" ]]; then
            echo "âŒ Error: Required files not found"
            echo "   SHA256 file exists: $([[ -f "$SHA256FILE" ]] && echo 'yes' || echo 'no')"
            echo "   Download file exists: $([[ -f "$FILENAME" ]] && echo 'yes' || echo 'no')"
            ls -la "$SHA256FILE" "$FILENAME" 2>&1 || true
            exit 1
          fi
          echo "âœ“ Files exist: $FILENAME, $SHA256FILE"
          
          # Debug: Show file sizes
          SHA_SIZE=$(wc -c < "$SHA256FILE")
          FILE_SIZE=$(wc -c < "$FILENAME")
          echo "ğŸ“„ File sizes - SHA256: ${SHA_SIZE} bytes, Archive: ${FILE_SIZE} bytes"
          
          # Debug: Show SHA256 file content (first 200 chars)
          echo "ğŸ“ SHA256 file content (first 200 chars):"
          head -c 200 "$SHA256FILE" | sed 's/^/   /'
          echo ""
          
          # Extract expected SHA256 - try multiple methods
          echo "ğŸ”¢ Extracting expected SHA256..."
          
          # Method 1: Get first 64-character hex string from file
          EXPECTED_SHA=$(grep -E '[a-fA-F0-9]{64}' "$SHA256FILE" | head -n1 | grep -oE '[a-fA-F0-9]{64}' | head -n1)
          
          # Method 2: If empty, try reading first line and extracting hex
          if [[ -z "$EXPECTED_SHA" ]]; then
            FIRST_LINE=$(head -n1 "$SHA256FILE")
            EXPECTED_SHA=$(echo "$FIRST_LINE" | grep -oE '[a-fA-F0-9]{64}' | head -n1)
          fi
          
          if [[ -z "$EXPECTED_SHA" ]]; then
            echo "âŒ Error: Could not extract SHA256 hash from $SHA256FILE"
            echo "   Content preview (first 3 lines):"
            head -n3 "$SHA256FILE" | sed 's/^/   /'
            exit 1
          fi
          
          # Validate SHA256 format
          if [[ ! "$EXPECTED_SHA" =~ ^[a-fA-F0-9]{64}$ ]]; then
            echo "âŒ Error: Extracted SHA256 has invalid format: $EXPECTED_SHA"
            exit 1
          fi
          
          echo "âœ“ Expected SHA256: $EXPECTED_SHA"
          
          # Compute actual SHA256
          echo "âš™ï¸ Computing actual SHA256..."
          ACTUAL_SHA=$(sha256sum "$FILENAME" 2>/dev/null | awk '{print $1}')
          if [[ -z "$ACTUAL_SHA" ]] || [[ ! "$ACTUAL_SHA" =~ ^[a-fA-F0-9]{64}$ ]]; then
            echo "âŒ Error: Could not compute valid SHA256"
            exit 1
          fi
          echo "âœ“ Actual SHA256: $ACTUAL_SHA"
          
          # Compare
          if [[ "$EXPECTED_SHA" != "$ACTUAL_SHA" ]]; then
            echo "âŒ Error: SHA256 mismatch!"
            echo "   Expected: $EXPECTED_SHA"
            echo "   Actual:   $ACTUAL_SHA"
            exit 1
          fi
          echo "âœ“ SHA256 verification passed"
          
          # Verify archive integrity
          tar -tzf "$FILENAME" >/dev/null 2>&1 || { echo "âŒ Error: Invalid or corrupted archive"; exit 1; }
          echo "âœ“ Archive integrity verified"
          
          # Check for required executable
          tar -tzf "$FILENAME" | grep -qE '(^|/)AdGuardHome$' || { echo "âŒ Error: Archive does not contain AdGuardHome executable"; exit 1; }
          echo "âœ“ AdGuardHome executable found in archive"
          
          # Check file size
          SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || echo 0)
          echo "âœ“ File size: $SIZE bytes"
          
          [[ $SIZE -ge ${{ env.MIN_FILE_SIZE }} ]] || { echo "âŒ Error: File too small (< $(( ${{ env.MIN_FILE_SIZE }} / 1000000 ))MB)"; exit 1; }
          [[ $SIZE -le ${{ env.MAX_FILE_SIZE }} ]] || { echo "âŒ Error: File too large (> $(( ${{ env.MAX_FILE_SIZE }} / 1000000 ))MB)"; exit 1; }
          echo "âœ“ File size within acceptable range"
          
          # Security scan: Check for suspicious files
          SUSPICIOUS_COUNT=$(tar -tzf "$FILENAME" | grep -iE '(\.sh$|\.bash$|\.py$|\.pl$|\.rb$)' | wc -l)
          if [[ $SUSPICIOUS_COUNT -gt 5 ]]; then
            echo "âš ï¸  Warning: Archive contains $SUSPICIOUS_COUNT potentially executable files"
          else
            echo "âœ“ Security scan passed (found $SUSPICIOUS_COUNT script files)"
          fi
          
          echo ""
          echo "âœ… All verification checks passed successfully"

      - name: Delete old release
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          echo "ğŸ—‘ï¸ Checking for existing v-latest release..."
          
          if gh release view v-latest >/dev/null 2>&1; then
            echo "âœ“ Found existing v-latest release, deleting..."
            if gh release delete v-latest --yes --cleanup-tag; then
              echo "âœ“ Successfully deleted old release"
            else
              echo "âš ï¸  Warning: Failed to delete old release, continuing..."
            fi
          else
            echo "âœ“ No existing v-latest release found (this is normal for first run)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create new release
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          
          [[ -n "$VERSION" && -f "$FILENAME" ]] || { echo "Error: Missing required data"; exit 1; }
          
          gh release create v-latest \
            --title "AdGuardHome v${VERSION}" \
            --notes "## AdGuardHome v${VERSION}
          
          **Update time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          **Source:** ${{ env.REPO }}
          
          **Architecture:** ${{ env.ARCH }}
          
          ### Installation
          \`\`\`bash
          tar -xzf ${FILENAME}
          sudo ./AdGuardHome -s install
          \`\`\`
          
          ### Download URL
          **Fixed download link (always points to latest version):**
          \`\`\`
          https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}
          \`\`\`" \
            "$FILENAME"
          
          echo "Release created successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test download URL
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          FILENAME="${{ steps.download.outputs.filename }}"
          TEST_URL="https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}"
          
          echo "ğŸ§ª Testing download URL availability..."
          echo "URL: $TEST_URL"
          
          # Wait for GitHub CDN to propagate (increase wait time)
          echo "â³ Waiting for CDN propagation..."
          sleep 10
          
          # Test URL with HEAD request
          echo "ğŸ“¡ Testing URL with HEAD request..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -I --max-time 30 "$TEST_URL" 2>/dev/null || echo "000")
          
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "âœ“ Download URL is accessible (HTTP $HTTP_STATUS)"
          elif [[ "$HTTP_STATUS" == "302" ]] || [[ "$HTTP_STATUS" == "301" ]]; then
            echo "âœ“ Download URL redirects properly (HTTP $HTTP_STATUS)"
          else
            echo "âš ï¸  Warning: Download URL returned HTTP $HTTP_STATUS (may need more time to propagate)"
          fi
          
          # Test actual download (first 1KB) - with error handling
          echo "ğŸ“¥ Testing actual download (first 1KB)..."
          if curl -s -r 0-1024 --max-time 15 --fail "$TEST_URL" 2>/dev/null | head -c 1024 | wc -c | grep -qE '^1024$'; then
            echo "âœ“ Download test passed (first 1KB retrieved successfully)"
          else
            echo "âš ï¸  Warning: Could not download test chunk (CDN may still be propagating or test failed)"
            # Don't fail the workflow if test download fails
            echo "   This is not critical - the release was created successfully"
          fi

      - name: Send success notification
        if: steps.download.outputs.filename && success()
        run: |
          echo "âœ“ Update completed successfully"
          echo "  - Version: ${{ steps.version.outputs.version }}"
          echo "  - File: ${{ steps.download.outputs.filename }}"
          echo "  - Download URL: https://github.com/${{ github.repository }}/releases/download/v-latest/${{ steps.download.outputs.filename }}"
          
          # Optional: Add Slack/Discord/Email notifications here
          # if [[ "${{ env.ENABLE_NOTIFICATIONS }}" == "true" ]] && [[ "${{ env.NOTIFY_ON_SUCCESS }}" == "true" ]]; then
          #   curl -X POST -H 'Content-type: application/json' \
          #     --data '{"text":"AdGuardHome updated to v${{ steps.version.outputs.version }}"}' \
          #     ${{ secrets.NOTIFICATION_WEBHOOK }}
          # fi

      - name: Collect metrics
        if: always()
        id: metrics
        run: |
          set -euo pipefail
          END_TIME=$(date +%s)
          START_TIME="${{ steps.init.outputs.start_time }}"
          DURATION=$((END_TIME - START_TIME))
          
          echo "duration=$DURATION" >> "$GITHUB_OUTPUT"
          echo "exit_code=${{ job.status == 'success' && '0' || '1' }}" >> "$GITHUB_OUTPUT"
          echo "version_checked=${{ steps.version.outputs.version || 'none' }}" >> "$GITHUB_OUTPUT"
          echo "update_performed=${{ steps.download.outputs.filename && 'true' || 'false' }}" >> "$GITHUB_OUTPUT"
          
          echo "âœ“ Metrics collected"
          echo "  - Duration: ${DURATION}s"
          echo "  - Update performed: ${{ steps.download.outputs.filename && 'true' || 'false' }}"

      - name: Log execution info
        if: always()
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘        AdGuardHome Auto Update - Execution Summary          â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Workflow Information:"
          echo "   â€¢ Repository:      ${{ github.repository }}"
          echo "   â€¢ Workflow ID:     ${{ github.run_id }}"
          echo "   â€¢ Run Number:      ${{ github.run_number }}"
          echo "   â€¢ Started:         ${{ steps.init.outputs.workflow_started_at }}"
          echo "   â€¢ Duration:        ${{ steps.metrics.outputs.duration }}s"
          echo "   â€¢ Status:          ${{ job.status }}"
          echo ""
          echo "ğŸ” Version Information:"
          echo "   â€¢ Latest Version:  ${{ steps.version.outputs.version || 'N/A' }}"
          echo "   â€¢ Current Version: ${{ steps.current.outputs.current || 'N/A' }}"
          echo "   â€¢ Update Needed:   ${{ steps.compare.outputs.needs_update || 'N/A' }}"
          echo "   â€¢ Update Performed: ${{ steps.metrics.outputs.update_performed }}"
          echo ""
          echo "ğŸ”— Fixed Download URL (NEVER CHANGES):"
          echo "   https://github.com/${{ github.repository }}/releases/download/v-latest/AdGuardHome_${{ env.ARCH }}.tar.gz"
          echo ""
          echo "ğŸ“ˆ Performance Metrics:"
          echo "   â€¢ API Timeout:     ${{ env.TIMEOUT }}s"
          echo "   â€¢ Max Retries:     ${{ env.RETRIES }}"
          echo "   â€¢ Download Time:   ${{ env.CURL_MAX_TIME }}s max"
          echo "   â€¢ Min File Size:   $(( ${{ env.MIN_FILE_SIZE }} / 1000000 ))MB"
          echo "   â€¢ Max File Size:   $(( ${{ env.MAX_FILE_SIZE }} / 1000000 ))MB"
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    End of Summary                           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Handle failure
        if: failure()
        run: |
          echo "âŒ Workflow failed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "Failure details:"
          echo "  - Job status: ${{ job.status }}"
          echo "  - Failed step: Check logs above"
          echo "  - Version checked: ${{ steps.version.outputs.version || 'N/A' }}"
          echo ""
          echo "Troubleshooting steps:"
          echo "  1. Check network connectivity to GitHub API"
          echo "  2. Verify GITHUB_TOKEN permissions"
          echo "  3. Check if AdGuardHome repository is accessible"
          echo "  4. Verify download URL format hasn't changed"
          echo ""
          
          # Create issue on failure (optional)
          # if [[ "${{ env.ENABLE_NOTIFICATIONS }}" == "true" ]] && [[ "${{ env.NOTIFY_ON_FAILURE }}" == "true" ]]; then
          #   gh issue create \
          #     --title "AdGuardHome update failed - $(date -u '+%Y-%m-%d')" \
          #     --body "Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
          #     --label "bug" \
          #     --label "automated"
          # fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          rm -f AdGuardHome_*.tar.gz AdGuardHome_*.sha256
          echo "Cleanup completed"

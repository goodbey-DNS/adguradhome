name: AdGuardHome Auto Update
on:
  schedule:
    - cron: '0 22 * * *'  # 每天6点自动检查
  workflow_dispatch:      # 手动触发，无参数

permissions:
  contents: write

env:
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  TIMEOUT: 30
  MAX_RETRIES: 3
  MIN_SIZE_MB: 10
  MAX_SIZE_MB: 50

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 20          # 防止退避超时
    concurrency:
      group: adguard-update
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -qq && sudo apt-get install -y -qq jq curl
          jq --version >/dev/null || exit 1
          curl --version >/dev/null || exit 1

      # 1. 获取官方最新版本（零函数，零作用域问题）
      - name: Get official version
        id: official
        run: |
          set -euo pipefail
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            # 内联所有变量，避免作用域陷阱
            CODE=$(curl -s -w "%{http_code}" --max-time ${{ env.TIMEOUT }} \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -o /tmp/official.json \
              "https://api.github.com/repos/${{ env.REPO }}/releases/latest" 2>/dev/null || echo "000")
            
            [[ "$CODE" == "200" ]] && \
            VERSION=$(jq -r '.tag_name // empty' /tmp/official.json | sed 's/^v//') && \
            [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] && break
            
            sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
          done
          
          [[ -n "${VERSION:-}" ]] || exit 1
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "✓ Latest version: v$VERSION"

      # 2. 本地版本（无则none）
      - name: Get current version
        id: current
        run: |
          set -euo pipefail
          RESP=$(curl -s -w "\n%{http_code}" --max-time ${{ env.TIMEOUT }} \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/v-latest" 2>/dev/null || true)
          
          CODE=$(echo "$RESP" | tail -n1)
          BODY=$(echo "$RESP" | head -n-1)
          
          if [[ "$CODE" == "200" ]]; then
            CURRENT=$(echo "$BODY" | jq -r '.name // "none"' | sed -n 's/.*v\([0-9.]*\).*/\1/p')
            [[ "$CURRENT" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || CURRENT="none"
          else
            CURRENT="none"
          fi
          
          echo "current=${CURRENT:-none}" >> $GITHUB_OUTPUT
          echo "✓ Current version: ${CURRENT:-none}"

      # 3. 决策（手动触发=强制更新）
      - name: Decide action
        id: decide
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || \
             [[ "${{ steps.current.outputs.current }}" != "${{ steps.official.outputs.version }}" ]]; then
            echo "should_update=true" >> $GITHUB_OUTPUT
            echo "✓ Update needed: ${{ steps.current.outputs.current }} → ${{ steps.official.outputs.version }}"
          else
            echo "should_update=false" >> $GITHUB_OUTPUT
            echo "✓ Already latest: v${{ steps.official.outputs.version }}"
          fi

      # 4. 下载并验证（损坏即重试）— FIX: 修复 continue 语法错误
      - name: Download
        if: steps.decide.outputs.should_update == 'true'
        id: download
        run: |
          set -euo pipefail
          cd ${{ github.workspace }}
          rm -f AdGuardHome_${{ env.ARCH }}.tar.gz AdGuardHome_${{ env.ARCH }}.tar.gz.sha256
          
          BASE="https://github.com/${{ env.REPO }}/releases/download/v${{ steps.official.outputs.version }}"
          FILE="AdGuardHome_${{ env.ARCH }}.tar.gz"
          SHA="AdGuardHome_${{ env.ARCH }}.tar.gz.sha256"
          
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            echo "Download attempt $i/${{ env.MAX_RETRIES }}..."
            
            # FIX1: 改用 || { ...; continue; } 链式语法，避免 if 块内 continue 语法错误
            curl -L --fail --max-time 300 -o "$FILE" "$BASE/$FILE" || {
              echo "Failed: $FILE"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            curl -L --fail --max-time ${{ env.TIMEOUT }} -o "$SHA" "$BASE/$SHA" || {
              echo "Failed: $SHA"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            # 验证文件
            [[ -s "$FILE" && -s "$SHA" ]] || {
              echo "Empty files"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            # FIX2: 所有 grep 末尾加 || true，防止空文件触发 set -e
            EXPECTED=$(grep -oE '^[a-fA-F0-9]{64}' "$SHA" | head -n1 || true) || true
            if [[ -z "$EXPECTED" ]]; then
              EXPECTED=$(grep -oE '[a-fA-F0-9]{64}' "$SHA" | head -n1 || true) || true
            fi
            if [[ -z "$EXPECTED" ]]; then
              EXPECTED=$(head -n1 "$SHA" 2>/dev/null | grep -oE '[a-fA-F0-9]{64}' || true) || true
            fi
            if [[ -z "$EXPECTED" ]]; then
              echo "Cannot extract SHA256"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            ACTUAL=$(sha256sum "$FILE" | awk '{print $1}')
            [[ "$EXPECTED" == "$ACTUAL" ]] || {
              echo "SHA256 mismatch"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            # 验证archive
            tar -tzf "$FILE" >/dev/null 2>&1 || {
              echo "Invalid archive"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            # 验证大小
            SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo 0)
            [[ $SIZE -gt $(( ${{ env.MIN_SIZE_MB }} * 1024 * 1024 )) ]] || {
              echo "File too small"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            [[ $SIZE -lt $(( ${{ env.MAX_SIZE_MB }} * 1024 * 1024 )) ]] || {
              echo "File too large"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            }
            
            # 全部通过
            break
          done || exit 1
          
          [[ -f "$FILE" ]] || exit 1
          echo "filename=$FILE" >> $GITHUB_OUTPUT
          echo "✓ Download and verification passed"

      # 5. 原子发布（fixed URL）
      - name: Publish
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          gh release view v-latest >/dev/null 2>&1 && \
            gh release delete v-latest --yes --cleanup-tag || true
          
          gh release create v-latest \
            --title "AdGuardHome v${{ steps.official.outputs.version }}" \
            --notes "Auto-update to v${{ steps.official.outputs.version }}" \
            "${{ steps.download.outputs.filename }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 6. 幂等清理（永不失败）
      - name: Cleanup
        if: always()
        run: rm -f ${{ github.workspace }}/AdGuardHome_*.tar.gz* 2>/dev/null || true

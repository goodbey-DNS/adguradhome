name: AdGuardHome Auto Update
on:
  schedule:
    - cron: '0 22 * * *'  # UTC时间22点（北京时间6点）自动检查
  workflow_dispatch:      # 手动触发，无参数

permissions:
  contents: write  # 需要创建release
  issues: write    # 需要创建issue

env:
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  TIMEOUT: 30
  MAX_RETRIES: 3
  MIN_SIZE_MB: 10
  MAX_SIZE_MB: 50

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 20          # 防止退避超时
    concurrency:
      group: adguard-update
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -qq && sudo apt-get install -y -qq jq curl
          jq --version >/dev/null || exit 1
          curl --version >/dev/null || exit 1

      # 1. 获取官方最新版本
      - name: Get official version
        id: official
        run: |
          set -euo pipefail
          VERSION=""
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            CODE=$(curl -s -w "%{http_code}" --max-time ${{ env.TIMEOUT }} \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -o /tmp/official.json \
              "https://api.github.com/repos/${{ env.REPO }}/releases/latest" 2>/dev/null || echo "000")
            
            if [[ "$CODE" == "200" ]]; then
              if VERSION=$(jq -r '.tag_name // empty' /tmp/official.json | sed 's/^v//'); then
                if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                  break
                fi
              fi
            fi
            
            if [[ $i -lt ${{ env.MAX_RETRIES }} ]]; then
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
            fi
          done
          
          if [[ -z "$VERSION" ]]; then
            echo "::error::Failed to get version after ${{ env.MAX_RETRIES }} retries"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "✓ Latest version: v$VERSION"

      # 2. 本地版本（无则none）
      - name: Get current version
        id: current
        run: |
          set -euo pipefail
          RESP=$(curl -s -w "\n%{http_code}" --max-time ${{ env.TIMEOUT }} \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/v-latest" 2>/dev/null || true)
          
          Code=$(echo "$RESP" | tail -n1)
          Body=$(echo "$RESP" | head -n-1)
          
          if [[ "$Code" == "200" ]]; then
            Current=$(echo "$Body" | jq -r '.name // "none"' | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | sed 's/^v//')
            [[ "$Current" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || Current="none"
          else
            Current="none"
          fi
          
          echo "current=${Current:-none}" >> $GITHUB_OUTPUT
          echo "✓ Current version: ${Current:-none}"

      # 3. 决策（手动触发=强制更新）
      - name: Decide action
        id: decide
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || \
             [[ "${{ steps.current.outputs.current }}" != "${{ steps.official.outputs.version }}" ]]; then
            echo "should_update=true" >> $GITHUB_OUTPUT
            echo "✓ Update needed: ${{ steps.current.outputs.current }} → ${{ steps.official.outputs.version }}"
          else
            echo "should_update=false" >> $GITHUB_OUTPUT
            echo "✓ Already latest: v${{ steps.official.outputs.version }}"
          fi

      # 4. 下载并验证（损坏即重试）
      - name: Download
        if: steps.decide.outputs.should_update == 'true'
        id: download
        run: |
          set -euo pipefail
          cd ${{ github.workspace }}
          rm -f AdGuardHome_${{ env.ARCH }}.tar.gz AdGuardHome_${{ env.ARCH }}.tar.gz.sha256
          
          BASE="https://github.com/${{ env.REPO }}/releases/download/v${{ steps.official.outputs.version }}"
          FILE="AdGuardHome_${{ env.ARCH }}.tar.gz"
          SHA="AdGuardHome_${{ env.ARCH }}.tar.gz.sha256"
          
          for i in $(seq 1 ${{ env.MAX_RETRIES }}); do
            echo "Download attempt $i/${{ env.MAX_RETRIES }}..."
            
            # 下载文件
            if ! curl -L --fail --max-time 300 -o "$FILE" "$BASE/$FILE"; then
              echo "Failed: $FILE"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            if ! curl -L --fail --max-time ${{ env.TIMEOUT }} -o "$SHA" "$BASE/$SHA"; then
              echo "Failed: $SHA"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            # 验证文件
            if [[ ! -s "$FILE" || ! -s "$SHA" ]]; then
              echo "Empty files"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            # 提取并验证SHA256（简化逻辑）
            EXPECTED=$(grep -oE '[a-fA-F0-9]{64}' "$SHA" | head -n1) || true
            if [[ -z "$EXPECTED" ]]; then
              echo "Cannot extract SHA256 from $SHA"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            ACTUAL=$(sha256sum "$FILE" | awk '{print $1}')
            if [[ "$EXPECTED" != "$ACTUAL" ]]; then
              echo "SHA256 mismatch"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            # 验证archive
            if ! tar -tzf "$FILE" >/dev/null 2>&1; then
              echo "Invalid archive"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            # 验证大小
            SIZE=$(stat -c%s "$FILE" 2>/dev/null || echo 0)
            if [[ $SIZE -le $(( ${{ env.MIN_SIZE_MB }} * 1024 * 1024 )) ]]; then
              echo "File too small"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            if [[ $SIZE -ge $(( ${{ env.MAX_SIZE_MB }} * 1024 * 1024 )) ]]; then
              echo "File too large"
              sleep $(( 2 ** i < 60 ? 2 ** i : 60 ))
              continue
            fi
            
            # 全部通过
            break
          done || exit 1
          
          [[ -f "$FILE" ]] || exit 1
          echo "filename=$FILE" >> $GITHUB_OUTPUT
          echo "✓ Download and verification passed"

      # 5. 原子发布（fixed URL）
      - name: Publish
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          gh release view v-latest >/dev/null 2>&1 && \
            gh release delete v-latest --yes --cleanup-tag || true
          
          gh release create v-latest \
            --title "AdGuardHome v${{ steps.official.outputs.version }}" \
            --notes "Auto-update to v${{ steps.official.outputs.version }}" \
            "${{ steps.download.outputs.filename }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 6. 幂等清理（永不失败）
      - name: Cleanup
        if: always()
        run: rm -f ${{ github.workspace }}/AdGuardHome_*.tar.gz* 2>/dev/null || true

      # 7. 失败通知
      - name: Notify on failure
        if: failure()
        run: |
          TITLE="AdGuardHome Update Failed - $(date +%Y-%m-%d)"
          BODY="## Auto-update workflow failed

          **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          **Official Version:** ${{ steps.official.outputs.version }}
          
          **Current Version:** ${{ steps.current.outputs.current }}
          
          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          Please check the workflow logs for details."
          
          # Create or update issue
          ISSUE_NUMBER=$(gh issue list --search "$TITLE" --state open --json number --jq '.[0].number')
          if [[ -n "$ISSUE_NUMBER" ]]; then
            gh issue comment "$ISSUE_NUMBER" --body "$BODY"
          else
            gh issue create --title "$TITLE" --body "$BODY" --label "bug"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

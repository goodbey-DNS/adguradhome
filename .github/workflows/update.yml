name: AdGuardHome Auto Update
# Description: Automatically checks for AdGuardHome updates daily at 6 AM Beijing time (UTC 22:00)
# and maintains a fixed download URL that always points to the latest version.

on:
  schedule:
    - cron: '0 22 * * *'  # 6 AM Beijing Time (UTC+8)
  workflow_dispatch:

permissions:
  contents: write

env:
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  TIMEOUT: 30
  RETRIES: 3
  RETRY_DELAY_BASE: 5
  MIN_FILE_SIZE: 10000000
  MAX_FILE_SIZE: 50000000
  CURL_MAX_TIME: 300

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: adguard-update
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq curl
          echo "✓ Tools ready"

      - name: Get latest version
        id: version
        run: |
          set -euo pipefail
          
          get_latest() {
            local response
            local http_code
            
            response=$(curl -s -w "\n%{http_code}" --max-time "$TIMEOUT" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/releases/latest" 2>/dev/null)
            
            http_code=$(echo "$response" | tail -n1)
            
            if [[ "$http_code" != "200" ]]; then
              return 1
            fi
            
            echo "$response" | head -n-1 | jq -r '.tag_name // empty'
          }
          
          VERSION=""
          for i in $(seq 1 "$RETRIES"); do
            echo "Fetching latest version (attempt $i/$RETRIES)..."
            
            local tag
            tag=$(get_latest)
            
            if [[ $? -eq 0 && -n "$tag" ]]; then
              VERSION=$(echo "$tag" | sed 's/^v//')
              
              # Validate version format (semantic versioning)
              if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                break
              else
                echo "Warning: Invalid version format: $VERSION"
                VERSION=""
              fi
            fi
            
            [[ $i -lt $RETRIES ]] && sleep $((RETRY_DELAY_BASE ** i))
          done
          
          [[ -n "$VERSION" ]] || { echo "Error: Failed to get valid version after $RETRIES attempts"; exit 1; }
          
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "✓ Latest version: $VERSION"

      - name: Get current version
        id: current
        run: |
          set -euo pipefail
          
          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time "$TIMEOUT" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/v-latest" \
            2>/dev/null || echo "")
          
          if [[ -z "$RESPONSE" ]]; then
            CURRENT="none"
          else
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            
            if [[ "$HTTP_CODE" == "404" ]]; then
              CURRENT="none"
            elif [[ "$HTTP_CODE" == "200" ]]; then
              local name
              name=$(echo "$RESPONSE" | head -n-1 | jq -r '.name // "none"')
              
              # Extract version from name (e.g., "v1.2.3" -> "1.2.3")
              if [[ "$name" =~ v([0-9]+\.[0-9]+\.[0-9]+) ]]; then
                CURRENT="${BASH_REMATCH[1]}"
              else
                CURRENT="none"
              fi
            else
              echo "Warning: Unexpected HTTP $HTTP_CODE"
              CURRENT="none"
            fi
          fi
          
          echo "current=$CURRENT" >> "$GITHUB_OUTPUT"
          echo "✓ Current version: $CURRENT"

      - name: Check if update needed
        id: check
        run: |
          set -euo pipefail
          
          LATEST="${{ steps.version.outputs.version }}"
          CURRENT="${{ steps.current.outputs.current }}"
          
          if [[ "$CURRENT" == "none" ]] || [[ "$CURRENT" != "$LATEST" ]]; then
            echo "update=true" >> "$GITHUB_OUTPUT"
            echo "✓ Update needed: $CURRENT → $LATEST"
          else
            echo "update=false" >> "$GITHUB_OUTPUT"
            echo "✓ Already latest: v$LATEST"
          fi

      - name: Download AdGuardHome
        if: steps.check.outputs.update == 'true'
        run: |
          set -euo pipefail
          
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="AdGuardHome_${ARCH}.tar.gz"
          SHA256SUMS="AdGuardHome_${ARCH}.tar.gz.sha256"
          BASE_URL="https://github.com/${REPO}/releases/download/v${VERSION}"
          
          echo "Downloading v${VERSION}..."
          
          for i in $(seq 1 "$RETRIES"); do
            echo "Download attempt $i/$RETRIES..."
            
            # Clean up any partial downloads
            rm -f "$FILENAME" "$SHA256SUMS"
            
            # Download files sequentially (more reliable)
            if ! curl -L --max-time "$CURL_MAX_TIME" -o "$FILENAME" "${BASE_URL}/${FILENAME}"; then
              echo "Failed to download $FILENAME"
              continue
            fi
            
            if ! curl -L --max-time "$TIMEOUT" -o "$SHA256SUMS" "${BASE_URL}/${SHA256SUMS}"; then
              echo "Failed to download $SHA256SUMS"
              continue
            fi
            
            # Verify files exist and have content
            if [[ -s "$FILENAME" && -s "$SHA256SUMS" ]]; then
              break
            fi
            
            echo "Downloaded files are empty or missing"
          done
          
          # Final verification
          [[ -s "$FILENAME" && -s "$SHA256SUMS" ]] || { echo "Error: Download failed after $RETRIES attempts"; exit 1; }
          
          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "sha256file=$SHA256SUMS" >> "$GITHUB_OUTPUT"
          echo "✓ Download completed"
        id: download

      - name: Verify integrity
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          
          FILENAME="${{ steps.download.outputs.filename }}"
          SHA256FILE="${{ steps.download.outputs.sha256file }}"
          
          [[ -f "$SHA256FILE" && -f "$FILENAME" ]] || { echo "Error: Required files not found"; exit 1; }
          
          # Extract SHA256 from file (first 64-char hex string)
          EXPECTED=$(grep -oE '^[a-fA-F0-9]{64}' "$SHA256FILE" | head -n1)
          
          if [[ -z "$EXPECTED" ]]; then
            # Try alternative: extract from any position
            EXPECTED=$(grep -oE '[a-fA-F0-9]{64}' "$SHA256FILE" | head -n1)
          fi
          
          [[ -n "$EXPECTED" ]] || { echo "Error: Cannot extract SHA256 hash from $SHA256FILE"; exit 1; }
          
          # Validate SHA256 format
          [[ "$EXPECTED" =~ ^[a-fA-F0-9]{64}$ ]] || { echo "Error: Invalid SHA256 format: $EXPECTED"; exit 1; }
          
          # Compute actual SHA256
          ACTUAL=$(sha256sum "$FILENAME" | awk '{print $1}')
          [[ -n "$ACTUAL" ]] || { echo "Error: Cannot compute SHA256"; exit 1; }
          
          [[ "$EXPECTED" == "$ACTUAL" ]] || { echo "Error: SHA256 mismatch"; echo "Expected: $EXPECTED"; echo "Actual:   $ACTUAL"; exit 1; }
          
          # Verify archive integrity
          tar -tzf "$FILENAME" >/dev/null 2>&1 || { echo "Error: Invalid or corrupted archive"; exit 1; }
          
          # Check file size
          SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || echo 0)
          [[ $SIZE -ge $MIN_FILE_SIZE && $SIZE -le $MAX_FILE_SIZE ]] || { echo "Error: File size $SIZE bytes outside allowed range"; exit 1; }
          
          echo "✓ Verification passed"

      - name: Delete old release
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          
          if gh release view v-latest >/dev/null 2>&1; then
            echo "Deleting existing v-latest release..."
            if gh release delete v-latest --yes --cleanup-tag 2>/dev/null; then
              echo "✓ Old release deleted"
            else
              echo "Warning: Failed to delete old release (may not exist or already deleted)"
            fi
          else
            echo "✓ No existing v-latest release to delete"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          
          [[ -n "$VERSION" && -f "$FILENAME" ]] || { echo "Error: Missing required data for release"; exit 1; }
          
          echo "Creating release v-latest for AdGuardHome v${VERSION}..."
          
          if gh release create v-latest \
            --title "AdGuardHome v${VERSION}" \
            --notes "## AdGuardHome v${VERSION}
          
          **Update time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          **Source:** $REPO
          
          **Architecture:** $ARCH
          
          ### Download URL
          https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}" \
            "$FILENAME"; then
            echo "✓ Release created successfully"
          else
            echo "Error: Failed to create release"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test download URL
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          
          FILENAME="${{ steps.download.outputs.filename }}"
          URL="https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}"
          
          sleep 10
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -I --max-time 30 "$URL" 2>/dev/null || echo "000")
          
          case "$HTTP_CODE" in
            200|301|302) echo "✓ URL test passed (HTTP $HTTP_CODE)" ;;
            *) echo "⚠️ URL test warning (HTTP $HTTP_CODE)" ;;
          esac

      - name: Cleanup
        if: always()
        run: rm -f AdGuardHome_*.tar.gz AdGuardHome_*.sha256

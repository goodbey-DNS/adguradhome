name: AdGuardHome Auto Update
on:
  schedule:
    - cron: '0 22 * * *'  # 6 AM Beijing Time
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update even if version is current'
        required: false
        default: 'false'
        type: choice
        options: ['true', 'false']

permissions:
  contents: write

env:
  # 声明但不依赖，仅供文档
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  TIMEOUT: 30

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    concurrency:
      group: adguard-update
      cancel-in-progress: false
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 核心：验证工具可用性，否则立即失败
      - name: Verify tools
        run: |
          jq --version >/dev/null || { sudo apt-get update -qq && sudo apt-get install -y -qq jq; }
          curl --version | head -1 || { sudo apt-get update -qq && sudo apt-get install -y -qq curl; }
          printf '%s\n' "jq=$(jq --version)" "curl=$(curl --version | head -1)"

      # 核心：使用here-string和立即验证
      - name: Get latest version
        id: version
        run: |
          set -eo pipefail
          
          # 内联重试循环，不封装函数
          for i in 1 2 3; do
            RESPONSE=$(curl -s --fail --max-time "${{ env.TIMEOUT }}" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ env.REPO }}/releases/latest") && \
            VERSION=$(jq -r '.tag_name // empty' <<< "$RESPONSE" | sed 's/^v//') && \
            [[ -n "$VERSION" ]] && break
            sleep $((2 ** i))
          done || { echo "ERROR: Failed after 3 attempts"; exit 1; }
          
          # 验证版本号格式
          [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || { echo "ERROR: Invalid version $VERSION"; exit 1; }
          
          printf 'version=%s\n' "$VERSION" >> "$GITHUB_OUTPUT"

      # 核心：区分响应为空和Not Found
      - name: Get current version
        id: current
        run: |
          set -eo pipefail
          
          RESPONSE=$(curl -s --fail --max-time "${{ env.TIMEOUT }}" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" 2>/dev/null || :)
          
          if [[ -z "$RESPONSE" ]] || jq -e '.message' <<< "$RESPONSE" >/dev/null 2>&1; then
            CURRENT="none"
          else
            CURRENT=$(jq -r '.name // "none"' <<< "$RESPONSE" | sed 's/^.*v\([0-9.]*\).*$/\1/')
          fi
          
          printf 'current=%s\n' "$CURRENT" >> "$GITHUB_OUTPUT"

      # 核心：显式比较，不使用嵌套变量
      - name: Check update necessity
        id: check
        run: |
          # 验证输出存在
          [[ -s "$GITHUB_OUTPUT" ]] || { echo "ERROR: No previous output"; exit 1; }
          
          LATEST="${{ steps.version.outputs.version }}"
          CURRENT="${{ steps.current.outputs.current }}"
          
          [[ -n "$LATEST" ]] || { echo "ERROR: Latest version missing"; exit 1; }
          
          # 修复：force_update输入必须生效
          UPDATE=false
          [[ "$CURRENT" == "none" ]] && UPDATE=true
          [[ "$CURRENT" != "$LATEST" ]] && UPDATE=true
          [[ "${{ github.event.inputs.force_update }}" == "true" ]] && UPDATE=true
          
          printf 'needs_update=%s\n' "$UPDATE" >> "$GITHUB_OUTPUT"

      # 核心：下载和验证一体化，任何失败立即退出
      - name: Atomic download and verify
        if: steps.check.outputs.needs_update == 'true'
        id: download
        run: |
          set -eo pipefail
          cd "${{ github.workspace }}"
          
          # 清理旧文件
          rm -f "AdGuardHome_${{ env.ARCH }}.tar.gz"
          
          URL="https://github.com/${{ env.REPO }}/releases/download/v${{ steps.version.outputs.version }}/AdGuardHome_${{ env.ARCH }}.tar.gz"
          FILENAME="AdGuardHome_${{ env.ARCH }}.tar.gz"
          
          # 修复：使用&&链确保命令顺序执行
          for i in 1 2 3; do
            curl -L --fail --max-time 300 -o "$FILENAME" "$URL" &&
            tar -tzf "$FILENAME" >/dev/null &&
            [[ $(stat -c%s "$FILENAME") -gt 10000000 ]] && break
            rm -f "$FILENAME"
            sleep $((2 ** i))
          done || exit 1
          
          # 最终验证文件存在
          [[ -f "$FILENAME" ]] || exit 1
          
          printf 'filename=%s\n' "$FILENAME" >> "$GITHUB_OUTPUT"

      # 核心：原子发布，使用--notes-file避免引号转义
      - name: Atomic release update
        if: steps.download.outputs.filename
        run: |
          set -eo pipefail
          cd "${{ github.workspace }}"
          
          FILENAME="${{ steps.download.outputs.filename }}"
          [[ -f "$FILENAME" ]] || exit 1
          
          # 删除旧release，忽略错误
          gh release view latest >/dev/null 2>&1 && \
            gh release delete latest --yes --cleanup-tag || true
          
          # 创建临时notes文件
          NOTES=$(mktemp)
          cat > "$NOTES" <<EOF
          ## AdGuardHome v${{ steps.version.outputs.version }}
          
          **Update time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          **Fixed download URL:**
          https://github.com/${{ github.repository }}/releases/download/latest/${FILENAME}
          EOF
          
          gh release create latest \
            --title "AdGuardHome v${{ steps.version.outputs.version }}" \
            --notes-file "$NOTES" \
            "$FILENAME"
          
          rm -f "$NOTES"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 核心：最终清理，永不失败
      - name: Final cleanup
        if: always()
        run: |
          rm -f "${{ github.workspace }}"/AdGuardHome_*.tar.gz 2>/dev/null || true

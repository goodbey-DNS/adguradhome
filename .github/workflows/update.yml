name: AdGuardHome Auto Update
# Description: Automatically checks for AdGuardHome updates daily at 6 AM Beijing time (UTC 22:00)
# and maintains a fixed download URL that always points to the latest version.
# 
# Features:
# - Daily automated version checks
# - Fixed download URL (never changes)
# - SHA256 integrity verification
# - Comprehensive error handling and logging
# - Retry mechanism with exponential backoff
# - Security scanning for downloaded files
# - Notification support (configurable)
# - Performance monitoring and metrics

on:
  schedule:
    - cron: '0 22 * * *'  # 6 AM Beijing Time (UTC+8)
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update even if version is current'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: write
  issues: write  # For creating issues on failure
  actions: read   # For workflow metrics

env:
  # Repository settings
  REPO: AdguardTeam/AdGuardHome
  ARCH: linux_amd64
  
  # Network settings
  TIMEOUT: 30
  RETRIES: 3
  RETRY_DELAY_BASE: 5  # Fixed: 5s base for proper exponential backoff (5, 25, 125s)
  RETRY_DELAY_MAX: 300  # Cap at 5 minutes
  
  # Security settings
  MIN_FILE_SIZE: 10000000  # 10MB minimum
  MAX_FILE_SIZE: 50000000  # 50MB maximum
  
  # Performance settings
  CURL_MAX_TIME: 300  # 5 minutes for download
  
  # Cache settings
  CACHE_VERSION: v2  # Increment when cache structure changes
  CACHE_DURATION: 3600  # 1 hour cache validity
  
  # Notification settings (optional)
  # ENABLE_NOTIFICATIONS: 'false'  # Set to 'true' to enable
  # NOTIFY_ON_SUCCESS: 'true'
  # NOTIFY_ON_FAILURE: 'true'

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: adguard-update
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache API responses
        uses: actions/cache@v4
        with:
          path: ~/.cache/api-responses
          key: api-cache-${{ env.CACHE_VERSION }}-${{ env.REPO }}-${{ hashFiles('**/update.yml') }}
          restore-keys: |
            api-cache-${{ env.CACHE_VERSION }}-${{ env.REPO }}-

      - name: Setup tools and environment
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq curl
          echo "jq version: $(jq --version)"
          echo "curl version: $(curl --version | head -n1)"
          
          # Create environment setup script for all subsequent steps
          cat > ~/.workflow_env << 'EOF'
          #!/bin/bash
          # Global environment setup - sourced by all subsequent steps
          set -euo pipefail
          
          # Export all workflow environment variables
          export REPO="${{ env.REPO }}"
          export ARCH="${{ env.ARCH }}"
          export TIMEOUT="${{ env.TIMEOUT }}"
          export RETRIES="${{ env.RETRIES }}"
          export RETRY_DELAY_BASE="${{ env.RETRY_DELAY_BASE }}"
          export RETRY_DELAY_MAX="${{ env.RETRY_DELAY_MAX }}"
          export MIN_FILE_SIZE="${{ env.MIN_FILE_SIZE }}"
          export MAX_FILE_SIZE="${{ env.MAX_FILE_SIZE }}"
          export CURL_MAX_TIME="${{ env.CURL_MAX_TIME }}"
          export CACHE_VERSION="${{ env.CACHE_VERSION }}"
          export CACHE_DURATION="${{ env.CACHE_DURATION }}"
          
          # Common utility functions
          retry_with_backoff() {
            local retry_function="$1"
            local max_retries="${2:-$RETRIES}"
            local base_delay="${3:-$RETRY_DELAY_BASE}"
            local max_delay="${4:-$RETRY_DELAY_MAX}"
            
            for i in $(seq 1 "$max_retries"); do
              if "$retry_function"; then
                return 0
              fi
              
              if [[ $i -eq $max_retries ]]; then
                return 1
              fi
              
              # Calculate exponential backoff with cap
              local delay=$(( base_delay ** i ))
              if [[ $delay -gt $max_delay ]]; then
                delay=$max_delay
              fi
              
              echo "â³ Waiting ${delay}s before retry (attempt $i/$max_retries)..."
              sleep "$delay"
            done
          }
          
          sanitize_cache_key() {
            local key="$1"
            # Replace unsafe characters with underscores
            echo "$key" | sed 's/[^a-zA-Z0-9._-]/_/g'
          }
          
          get_cached_response() {
            local cache_key="$1"
            local max_age="${2:-$CACHE_DURATION}"
            local safe_key
            safe_key=$(sanitize_cache_key "$cache_key")
            local cache_file="$HOME/.cache/api-responses/${safe_key}.json"
            
            if [[ -f "$cache_file" ]]; then
              local file_age
              file_age=$(($(date +%s) - $(stat -c %Y "$cache_file")))
              if [[ $file_age -lt $max_age ]]; then
                cat "$cache_file"
                return 0
              fi
            fi
            return 1
          }
          
          cache_response() {
            local cache_key="$1"
            local response="$2"
            local safe_key
            safe_key=$(sanitize_cache_key "$cache_key")
            local cache_dir="$HOME/.cache/api-responses"
            local cache_file="$cache_dir/${safe_key}.json"
            
            mkdir -p "$cache_dir"
            echo "$response" > "$cache_file"
          }
          EOF
          
          chmod +x ~/.workflow_env
          echo "âœ“ Environment setup completed"

      - name: Initialize workflow
        id: init
        run: |
          # Source environment setup
          source ~/.workflow_env
          
          START_TIME=$(date +%s)
          echo "start_time=$START_TIME" >> "$GITHUB_OUTPUT"
          echo "workflow_id=${{ github.run_id }}" >> "$GITHUB_OUTPUT"
          echo "workflow_started_at=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$GITHUB_OUTPUT"
          
          # Create working directory
          mkdir -p "${{ github.workspace }}/downloads"
          cd "${{ github.workspace }}/downloads"
          
          echo "âœ“ Workflow initialization completed"
          echo "  - Repository: ${{ github.repository }}"
          echo "  - Runner: ${{ runner.os }}"
          echo "  - Architecture: $ARCH"
          echo "  - Force update: ${{ github.event.inputs.force_update || 'false' }}"

      - name: Get latest version
        id: version
        run: |
          set -euo pipefail
          # Source environment setup
          source ~/.workflow_env
          
          # Define variables
          CACHE_KEY="latest_version_${REPO}"
          VERSION=""
          
          # Try cache first
          echo "ğŸ” Checking cache for latest version..."
          CACHED_VERSION=$(get_cached_response "$CACHE_KEY" || echo "")
          
          if [[ -n "$CACHED_VERSION" ]]; then
            VERSION=$(echo "$CACHED_VERSION" | jq -r '.tag_name // empty' | sed 's/^v//')
            if [[ -n "$VERSION" ]]; then
              echo "âœ“ Using cached latest version: $VERSION"
              echo "version=$VERSION" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi
          
          # Fetch from API with retry
          echo "ğŸ“¡ Fetching latest version from API..."
          get_version() {
            curl -s --max-time "$TIMEOUT" \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/$REPO/releases/latest" \
              2>/dev/null
          }
          
          RESPONSE=""
          if retry_with_backoff get_version; then
            RESPONSE=$(get_version)
            VERSION=$(echo "$RESPONSE" | jq -r '.tag_name // empty' | sed 's/^v//')
            if [[ -n "$VERSION" ]]; then
              echo "âœ“ Latest version: $VERSION"
              echo "version=$VERSION" >> "$GITHUB_OUTPUT"
              # Cache the response
              cache_response "$CACHE_KEY" "$RESPONSE"
              exit 0
            fi
          fi
          
          echo "âŒ Error: Cannot get version after $RETRIES attempts"
          exit 1

      - name: Get current version
        id: current
        run: |
          set -euo pipefail
          # Source environment setup
          source ~/.workflow_env
          
          # Define variables
          CACHE_KEY="current_version_${{ github.repository }}"
          CURRENT="none"
          
          # Try cache first
          echo "ğŸ” Checking cache for current version..."
          CACHED_RESPONSE=$(get_cached_response "$CACHE_KEY" 300 || echo "")  # 5 min cache
          
          if [[ -n "$CACHED_RESPONSE" ]]; then
            MSG=$(echo "$CACHED_RESPONSE" | jq -r '.message // empty')
            if [[ "$MSG" != "Not Found" ]]; then
              CURRENT=$(echo "$CACHED_RESPONSE" | jq -r '.name // "none"' | sed 's/^.*v\([0-9.]*\).*$/\1/' || echo "none")
            fi
            echo "âœ“ Using cached current version: $CURRENT"
            echo "current=$CURRENT" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Fetch from API
          echo "ğŸ“¡ Fetching current version from API..."
          RESPONSE=$(curl -s --max-time "$TIMEOUT" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/v-latest" \
            2>/dev/null || echo "")
          
          if [[ -n "$RESPONSE" ]]; then
            MSG=$(echo "$RESPONSE" | jq -r '.message // empty')
            if [[ "$MSG" != "Not Found" ]]; then
              CURRENT=$(echo "$RESPONSE" | jq -r '.name // "none"' | sed 's/^.*v\([0-9.]*\).*$/\1/' || echo "none")
            fi
          fi
          
          echo "âœ“ Current version: $CURRENT"
          echo "current=$CURRENT" >> "$GITHUB_OUTPUT"
          # Cache the response
          cache_response "$CACHE_KEY" "$RESPONSE"

      - name: Compare versions
        id: compare
        run: |
          set -euo pipefail
          
          LATEST="${{ steps.version.outputs.version }}"
          CURRENT="${{ steps.current.outputs.current }}"
          FORCE_UPDATE="${{ github.event.inputs.force_update || 'false' }}"
          
          echo "=== Version Comparison ==="
          echo "Latest from official: $LATEST"
          echo "Current in repo: $CURRENT"
          echo "Force update: $FORCE_UPDATE"
          echo "========================="
          
          if [[ "$FORCE_UPDATE" == "true" ]]; then
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
            echo "âœ“ Force update enabled: will update to v$LATEST"
          elif [[ "$CURRENT" == "none" ]] || [[ "$CURRENT" != "$LATEST" ]]; then
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
            echo "âœ“ Update needed: $CURRENT â†’ $LATEST"
          else
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
            echo "âœ“ Already latest: v$LATEST"
          fi

      - name: Download AdGuardHome
        if: steps.compare.outputs.needs_update == 'true'
        id: download
        run: |
          set -euo pipefail
          # Source environment setup
          source ~/.workflow_env
          
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="AdGuardHome_${ARCH}.tar.gz"
          SHA256SUMS="AdGuardHome_${ARCH}.tar.gz.sha256"
          BASE_URL="https://github.com/${REPO}/releases/download/v${VERSION}"
          
          echo "â¬‡ï¸  Starting download..."
          echo "   Version: v${VERSION}"
          echo "   Files: ${FILENAME}, ${SHA256SUMS}"
          
          DOWNLOAD_START=$(date +%s)
          
          # Download function with retry
          download_files() {
            # Clean up any previous partial downloads
            rm -f "$FILENAME" "$SHA256SUMS"
            
            echo "ğŸ“¥ Downloading files in parallel..."
            # Use parallel downloads with background jobs
            curl -L --max-time "$CURL_MAX_TIME" --retry 3 --retry-delay 5 \
              -o "$FILENAME" "${BASE_URL}/${FILENAME}" &
            CURL_PID1=$!
            
            curl -L --max-time "$TIMEOUT" --retry 3 --retry-delay 5 \
              -o "$SHA256SUMS" "${BASE_URL}/${SHA256SUMS}" &
            CURL_PID2=$!
            
            # Wait for both downloads to complete
            wait $CURL_PID1
            EXIT_CODE1=$?
            wait $CURL_PID2
            EXIT_CODE2=$?
            
            if [[ $EXIT_CODE1 -eq 0 ]] && [[ $EXIT_CODE2 -eq 0 ]] && \
               [[ -f "$FILENAME" ]] && [[ -f "$SHA256SUMS" ]]; then
              return 0
            fi
            
            echo "âš ï¸  Download failed (exit codes: $EXIT_CODE1, $EXIT_CODE2)"
            return 1
          }
          
          # Retry with exponential backoff
          if retry_with_backoff download_files; then
            echo "âœ“ Both files downloaded successfully"
          else
            echo "âŒ Error: Download failed after $RETRIES attempts"
            exit 1
          fi
          
          DOWNLOAD_END=$(date +%s)
          DOWNLOAD_DURATION=$((DOWNLOAD_END - DOWNLOAD_START))
          
          # Get file sizes
          FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || echo 0)
          SHA_SIZE=$(stat -c%s "$SHA256SUMS" 2>/dev/null || echo 0)
          
          echo ""
          echo "âœ“ Download completed in ${DOWNLOAD_DURATION}s"
          echo "  - Main file: $(( FILE_SIZE / 1024 / 1024 ))MB"
          echo "  - Checksum:  $(( SHA_SIZE / 1024 ))KB"
          
          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "sha256file=$SHA256SUMS" >> "$GITHUB_OUTPUT"
          echo "download_duration=$DOWNLOAD_DURATION" >> "$GITHUB_OUTPUT"

      - name: Verify download integrity
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          # Source environment setup
          source ~/.workflow_env
          
          FILENAME="${{ steps.download.outputs.filename }}"
          SHA256FILE="${{ steps.download.outputs.sha256file }}"
          
          echo "ğŸ” Starting integrity verification..."
          
          # Check files exist
          if [[ ! -f "$SHA256FILE" ]] || [[ ! -f "$FILENAME" ]]; then
            echo "âŒ Error: Required files not found"
            echo "   SHA256 file: $([[ -f "$SHA256FILE" ]] && echo 'exists' || echo 'missing')"
            echo "   Archive file: $([[ -f "$FILENAME" ]] && echo 'exists' || echo 'missing')"
            ls -lh "$SHA256FILE" "$FILENAME" 2>&1 || true
            exit 1
          fi
          echo "âœ“ Files exist: $FILENAME, $SHA256FILE"
          
          # Debug: Show file sizes
          SHA_SIZE=$(wc -c < "$SHA256FILE")
          FILE_SIZE=$(wc -c < "$FILENAME")
          echo "ğŸ“„ File sizes - SHA256: ${SHA_SIZE} bytes, Archive: ${FILE_SIZE} bytes"
          
          # Debug: Show SHA256 file content (first 200 chars)
          echo "ğŸ“ SHA256 file content (first 200 chars):"
          head -c 200 "$SHA256FILE" | sed 's/^/   /'
          echo ""
          
          # Extract expected SHA256 - try multiple methods
          echo "ğŸ”¢ Extracting expected SHA256..."
          
          # Method 1: Get first 64-character hex string from file
          EXPECTED_SHA=$(grep -E '[a-fA-F0-9]{64}' "$SHA256FILE" | head -n1 | grep -oE '[a-fA-F0-9]{64}' | head -n1)
          
          # Method 2: If empty, try reading first line and extracting hex
          if [[ -z "$EXPECTED_SHA" ]]; then
            FIRST_LINE=$(head -n1 "$SHA256FILE")
            EXPECTED_SHA=$(echo "$FIRST_LINE" | grep -oE '[a-fA-F0-9]{64}' | head -n1)
          fi
          
          if [[ -z "$EXPECTED_SHA" ]]; then
            echo "âŒ Error: Could not extract SHA256 hash from $SHA256FILE"
            echo "   Content preview (first 3 lines):"
            head -n3 "$SHA256FILE" | sed 's/^/   /'
            exit 1
          fi
          
          # Validate SHA256 format
          if [[ ! "$EXPECTED_SHA" =~ ^[a-fA-F0-9]{64}$ ]]; then
            echo "âŒ Error: Extracted SHA256 has invalid format: $EXPECTED_SHA"
            exit 1
          fi
          
          echo "âœ“ Expected SHA256: $EXPECTED_SHA"
          
          # Compute actual SHA256
          echo "âš™ï¸ Computing actual SHA256..."
          ACTUAL_SHA=$(sha256sum "$FILENAME" 2>/dev/null | awk '{print $1}')
          if [[ -z "$ACTUAL_SHA" ]] || [[ ! "$ACTUAL_SHA" =~ ^[a-fA-F0-9]{64}$ ]]; then
            echo "âŒ Error: Could not compute valid SHA256"
            exit 1
          fi
          echo "âœ“ Actual SHA256: $ACTUAL_SHA"
          
          # Compare
          if [[ "$EXPECTED_SHA" != "$ACTUAL_SHA" ]]; then
            echo "âŒ Error: SHA256 mismatch!"
            echo "   Expected: $EXPECTED_SHA"
            echo "   Actual:   $ACTUAL_SHA"
            exit 1
          fi
          echo "âœ“ SHA256 verification passed"
          
          # Verify archive integrity
          tar -tzf "$FILENAME" >/dev/null 2>&1 || { echo "âŒ Error: Invalid or corrupted archive"; exit 1; }
          echo "âœ“ Archive integrity verified"
          
          # Check for required executable
          tar -tzf "$FILENAME" | grep -qE '(^|/)AdGuardHome$' || { echo "âŒ Error: Archive does not contain AdGuardHome executable"; exit 1; }
          echo "âœ“ AdGuardHome executable found in archive"
          
          # Check file size
          SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || echo 0)
          echo "âœ“ File size: $SIZE bytes"
          
          [[ $SIZE -ge $MIN_FILE_SIZE ]] || { echo "âŒ Error: File too small (< $(( MIN_FILE_SIZE / 1000000 ))MB)"; exit 1; }
          [[ $SIZE -le $MAX_FILE_SIZE ]] || { echo "âŒ Error: File too large (> $(( MAX_FILE_SIZE / 1000000 ))MB)"; exit 1; }
          echo "âœ“ File size within acceptable range"
          
          # Security scan: Check for suspicious files
          SUSPICIOUS_COUNT=$(tar -tzf "$FILENAME" | grep -iE '(\.sh$|\.bash$|\.py$|\.pl$|\.rb$)' | wc -l)
          if [[ $SUSPICIOUS_COUNT -gt 5 ]]; then
            echo "âš ï¸  Warning: Archive contains $SUSPICIOUS_COUNT potentially executable files"
          else
            echo "âœ“ Security scan passed (found $SUSPICIOUS_COUNT script files)"
          fi
          
          echo ""
          echo "âœ… All verification checks passed successfully"

      - name: Delete old release
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          echo "ğŸ—‘ï¸ Checking for existing v-latest release..."
          
          if gh release view v-latest >/dev/null 2>&1; then
            echo "âœ“ Found existing v-latest release, deleting..."
            if gh release delete v-latest --yes --cleanup-tag; then
              echo "âœ“ Successfully deleted old release"
            else
              echo "âš ï¸  Warning: Failed to delete old release, continuing..."
            fi
          else
            echo "âœ“ No existing v-latest release found (this is normal for first run)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create new release
        if: steps.download.outputs.filename
        run: |
          # Source environment setup
          source ~/.workflow_env
          
          VERSION="${{ steps.version.outputs.version }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          
          [[ -n "$VERSION" && -f "$FILENAME" ]] || { echo "Error: Missing required data"; exit 1; }
          
          gh release create v-latest \
            --title "AdGuardHome v${VERSION}" \
            --notes "## AdGuardHome v${VERSION}
          
          **Update time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          **Source:** $REPO
          
          **Architecture:** $ARCH
          
          ### Installation
          \`\`\`bash
          tar -xzf ${FILENAME}
          sudo ./AdGuardHome -s install
          \`\`\`
          
          ### Download URL
          **Fixed download link (always points to latest version):**
          \`\`\`
          https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}
          \`\`\`" \
            "$FILENAME"
          
          echo "Release created successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Test download URL
        if: steps.download.outputs.filename
        run: |
          set -euo pipefail
          # Source environment setup
          source ~/.workflow_env
          
          FILENAME="${{ steps.download.outputs.filename }}"
          TEST_URL="https://github.com/${{ github.repository }}/releases/download/v-latest/${FILENAME}"
          
          echo "ğŸ§ª Testing download URL availability..."
          echo "   URL: $TEST_URL"
          
          # Wait for GitHub CDN to propagate
          echo "â³ Waiting 10s for CDN propagation..."
          sleep 10
          
          # Test URL with HEAD request
          echo "ğŸ“¡ Testing URL with HEAD request..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -I --max-time 30 "$TEST_URL" 2>/dev/null || echo "000")
          
          case "$HTTP_STATUS" in
            200)
              echo "âœ“ Download URL is accessible (HTTP $HTTP_STATUS)"
              ;;
            301|302)
              echo "âœ“ Download URL redirects properly (HTTP $HTTP_STATUS)"
              ;;
            000)
              echo "âš ï¸  Warning: Network request failed or timed out"
              ;;
            *)
              echo "âš ï¸  Warning: Download URL returned HTTP $HTTP_STATUS (CDN may need more time)"
              ;;
          esac
          
          # Test actual download (first 1KB) - with error handling
          echo "ğŸ“¥ Testing partial download (first 1KB)..."
          TEST_SIZE=$(curl -s -r 0-1024 --max-time 15 --fail "$TEST_URL" 2>/dev/null | wc -c || echo "0")
          
          if [[ "$TEST_SIZE" -eq 1025 ]]; then
            echo "âœ“ Download test passed (retrieved ${TEST_SIZE} bytes)"
          else
            echo "âš ï¸  Warning: Could not download test chunk (got ${TEST_SIZE} bytes)"
            echo "   CDN may still be propagating - this is not critical"
          fi
          
          echo ""
          echo "âœ“ URL test completed (release created successfully)"

      - name: Send success notification
        if: steps.download.outputs.filename && success()
        run: |
          echo "âœ“ Update completed successfully"
          echo "  - Version: ${{ steps.version.outputs.version }}"
          echo "  - File: ${{ steps.download.outputs.filename }}"
          echo "  - Download URL: https://github.com/${{ github.repository }}/releases/download/v-latest/${{ steps.download.outputs.filename }}"
          
          # Optional: Add Slack/Discord/Email notifications here
          # if [[ "${{ env.ENABLE_NOTIFICATIONS }}" == "true" ]] && [[ "${{ env.NOTIFY_ON_SUCCESS }}" == "true" ]]; then
          #   curl -X POST -H 'Content-type: application/json' \
          #     --data '{"text":"AdGuardHome updated to v${{ steps.version.outputs.version }}"}' \
          #     ${{ secrets.NOTIFICATION_WEBHOOK }}
          # fi

      - name: Collect metrics
        if: always()
        id: metrics
        run: |
          set -euo pipefail
          
          END_TIME=$(date +%s)
          START_TIME="${{ steps.init.outputs.start_time }}"
          DURATION=$((END_TIME - START_TIME))
          
          JOB_STATUS="${{ job.status }}"
          EXIT_CODE=$([[ "$JOB_STATUS" == "success" ]] && echo "0" || echo "1")
          VERSION_CHECKED="${{ steps.version.outputs.version || 'none' }}"
          UPDATE_PERFORMED=$([[ -n "${{ steps.download.outputs.filename }}" ]] && echo "true" || echo "false")
          
          echo "duration=$DURATION" >> "$GITHUB_OUTPUT"
          echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          echo "version_checked=$VERSION_CHECKED" >> "$GITHUB_OUTPUT"
          echo "update_performed=$UPDATE_PERFORMED" >> "$GITHUB_OUTPUT"
          
          echo ""
          echo "âœ“ Metrics collected:"
          echo "  - Duration: ${DURATION}s"
          echo "  - Exit code: $EXIT_CODE"
          echo "  - Version checked: $VERSION_CHECKED"
          echo "  - Update performed: $UPDATE_PERFORMED"

      - name: Log execution info
        if: always()
        run: |
          # Source environment setup
          source ~/.workflow_env
          
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘        AdGuardHome Auto Update - Execution Summary          â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Workflow Information:"
          echo "   â€¢ Repository:      ${{ github.repository }}"
          echo "   â€¢ Workflow ID:     ${{ github.run_id }}"
          echo "   â€¢ Run Number:      ${{ github.run_number }}"
          echo "   â€¢ Started:         ${{ steps.init.outputs.workflow_started_at }}"
          echo "   â€¢ Duration:        ${{ steps.metrics.outputs.duration }}s"
          echo "   â€¢ Status:          ${{ job.status }}"
          echo ""
          echo "ğŸ” Version Information:"
          echo "   â€¢ Latest Version:  ${{ steps.version.outputs.version || 'N/A' }}"
          echo "   â€¢ Current Version: ${{ steps.current.outputs.current || 'N/A' }}"
          echo "   â€¢ Update Needed:   ${{ steps.compare.outputs.needs_update || 'N/A' }}"
          echo "   â€¢ Update Performed: ${{ steps.metrics.outputs.update_performed }}"
          echo ""
          echo "ğŸ”— Fixed Download URL (NEVER CHANGES):"
          echo "   https://github.com/${{ github.repository }}/releases/download/v-latest/AdGuardHome_${ARCH}.tar.gz"
          echo ""
          echo "ğŸ“ˆ Performance Metrics:"
          echo "   â€¢ API Timeout:     ${TIMEOUT}s"
          echo "   â€¢ Max Retries:     ${RETRIES}"
          echo "   â€¢ Download Time:   ${CURL_MAX_TIME}s max"
          echo "   â€¢ Min File Size:   $(( MIN_FILE_SIZE / 1000000 ))MB"
          echo "   â€¢ Max File Size:   $(( MAX_FILE_SIZE / 1000000 ))MB"
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    End of Summary                           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Handle failure
        if: failure()
        run: |
          echo "âŒ Workflow failed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          echo "Failure details:"
          echo "  - Job status: ${{ job.status }}"
          echo "  - Failed step: Check logs above"
          echo "  - Version checked: ${{ steps.version.outputs.version || 'N/A' }}"
          echo ""
          echo "Troubleshooting steps:"
          echo "  1. Check network connectivity to GitHub API"
          echo "  2. Verify GITHUB_TOKEN permissions"
          echo "  3. Check if AdGuardHome repository is accessible"
          echo "  4. Verify download URL format hasn't changed"
          echo ""
          
          # Create issue on failure (optional)
          # if [[ "${{ env.ENABLE_NOTIFICATIONS }}" == "true" ]] && [[ "${{ env.NOTIFY_ON_FAILURE }}" == "true" ]]; then
          #   gh issue create \
          #     --title "AdGuardHome update failed - $(date -u '+%Y-%m-%d')" \
          #     --body "Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
          #     --label "bug" \
          #     --label "automated"
          # fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          rm -f AdGuardHome_*.tar.gz AdGuardHome_*.sha256
          echo "Cleanup completed"
